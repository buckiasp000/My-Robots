import pybullet as pimport time as timport pybullet_dataimport pyrosim.pyrosim as pyrosimimport numpy as npimport random as randamplitudeBL = np.pi/4frequencyBL = 10phaseOffsetBL = np.pi/3amplitudeFL = np.pi/4frequencyFL = 10phaseOffsetFL = 0physicsClient = p.connect(p.GUI)p.setAdditionalSearchPath(pybullet_data.getDataPath())p.setGravity(0,0,-200)robotId = p.loadURDF("body.urdf")planeId = p.loadURDF("plane.urdf")p.loadSDF("world.sdf")pyrosim.Prepare_To_Simulate(robotId)backLegSensorValues = np.zeros(1000)frontLegSensorValues = np.zeros(1000)targetAngles =  np.linspace(-np.pi, np.pi, 1000)targetAnglesBL = amplitudeBL * np.sin(frequencyBL * targetAngles + np.ones(1000) * phaseOffsetBL)targetAnglesFL = amplitudeFL * np.sin(frequencyFL * targetAngles + np.ones(1000) * phaseOffsetFL)print(targetAnglesBL[50])print(targetAnglesFL[50])np.save("data/targetAnglesBL.npy", targetAnglesBL)np.save("data/targetAnglesFL.npy", targetAnglesFL)for i in range(1000):        p.stepSimulation()        backLegSensorValues[i] = pyrosim.Get_Touch_Sensor_Value_For_Link("BackLeg")    frontLegSensorValues[i] = pyrosim.Get_Touch_Sensor_Value_For_Link("FrontLeg")        pyrosim.Set_Motor_For_Joint(bodyIndex = robotId, jointName = b'Torso_BackLeg', controlMode = p.POSITION_CONTROL, targetPosition = targetAnglesBL[i], maxForce = 500)    pyrosim.Set_Motor_For_Joint(bodyIndex = robotId, jointName = b'Torso_FrontLeg', controlMode = p.POSITION_CONTROL, targetPosition =  targetAnglesFL[i], maxForce = 500)    t.sleep(1/240)    print(i)p.disconnect()np.save("data/backLegSensorValues.npy", backLegSensorValues)np.save("data/frontLegSensorValues.npy", frontLegSensorValues)